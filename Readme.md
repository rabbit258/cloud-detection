### 这是什么？

一个基于论文实现的遥感云含量检测算法

### 实现参考来源及依赖

本算法参考的论文已经放在了paper中

实现代码时的依赖版本如下

> matplotlib = 3.7.1
>
> numpy = 1.23.5
>
> opencv-contrib-python = 4.7.0.72
>
> opencv-python = 4.7.0.72
>
> scikit-image = 0.20.0

在centos系统的测试中，高版本安装可能会遇到问题，故依赖版本修改为了

> opencv-contrib-python = 4.1.1.26
>
> opencv-python = 4.1.1.26

**--up:已按照要求对文件和共享库进行打包**

离线安装命令：

```
pip install --no-index --ignore-installed --find-links=./package -r requirements.txt
```



### 使用说明

算法的实现文件为`final.py`和`tool.py`

`dection.py`为功能集成好的主程序，运行后需要输入**两行**内容(程序并没有做格式处理)

第一行为待处理图片的路径

第二行为精度输出的文件路径

如：

```shell
[rabbit@localhost code]$ python3 detection.py 
./336.png
./test.txt
```

就会在当前目录的test.txt中写入图片的云覆盖率，比如打开 `test.txt`，你会看到

```
0.6797142028808594
```



如果你想要修改主程序的话请阅读下面的内容，否则可以直接忽略掉。

使用前需要先导入实现的包

`import final as fl `

检测主要使用包中的 `get_precision(img,debug=False)`函数

第一个参数代表需要云检测的图片

第二个参数代表是否开启`debug`。

如果`debug`为`false`，则只返回一个值，代表检测出的云覆盖率

否则将会返回两个值，第二个值为一张二值图，用于参考实际检测情况如何

详细请参考`detection.py`的用例

### 注意事项

期望的读入图片大小在10240*10240左右，**最好不要包含遥感图像专有的图片四周的黑框。**

论文中实现使用的近红外、红和绿波段作为R,G,B值计算。但是由于本人手头没有多波段的图片，也不知道实际运用中有没有多波段图片，所以采用了红，绿，蓝波段作为代替。

如需更改，只需要修改`tool.py`的`hand`函数开头即可，有详细的注释。

本代码由于算法本身的缺陷，在如下情况可能会有比较大的误差

* 云过多且规律整齐，无纹理
* 云的周围刚好有纹理清晰的地物
* 云成碎片化，且数量众多
* 云比较薄，放大图片甚至可见地物，此时认为卫星有自动去除薄云的能力

除了此外可能有没测试出来的情况，因为时间问题，实现和测试的比较匆忙，还望理解

